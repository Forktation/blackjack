use std::{
    fs::File,
    io::{BufReader, BufWriter, Write},
    path::PathBuf,
};
use wavefront_rs::obj::{
    self,
    entity::{Entity, FaceVertex},
};

use crate::prelude::*;

impl HalfEdgeMesh {
    pub fn to_wavefront_obj(&self, path: PathBuf) -> Result<()> {
        let mut writer = BufWriter::new(File::create(path)?);

        // We need to store the mapping between vertex ids and indices in the
        // generated OBJ
        // NOTE: OBJ Wavefront indices start at 1
        let mut imap = HashMap::<VertexId, i32>::new();

        obj::format_writer::FormatWriter::write(
            &mut writer,
            &Entity::Comment {
                content: "Generated by Blackjack: https://github.com/setzer22/blackjack".into(),
            },
        );
        writer.write_all("\n".as_ref())?;

        for (idx, (v_id, v)) in self.iter_vertices().enumerate() {
            imap.insert(v_id, (idx + 1) as i32);
            obj::format_writer::FormatWriter::write(
                &mut writer,
                &Entity::Vertex {
                    x: v.position.x as f64,
                    y: v.position.y as f64,
                    z: v.position.z as f64,
                    w: None,
                },
            );
            writer.write_all("\n".as_ref())?;
        }
        for (face_id, _) in self.iter_faces() {
            let vertices = self
                .face_vertices(face_id)
                .iter()
                .map(|v_id| FaceVertex {
                    vertex: imap[v_id] as i64,
                    normal: None,
                    texture: None,
                })
                .collect();
            obj::format_writer::FormatWriter::write(&mut writer, &Entity::Face { vertices });
            writer.write_all("\n".as_ref())?;
        }
        Ok(())
    }

    pub fn from_wavefront_obj(path: PathBuf) -> Result<HalfEdgeMesh> {
        let mut reader = BufReader::new(File::open(path)?);
        let mut positions = vec![];
        let mut polygons = vec![];
        obj::read_lexer::ReadLexer::read_to_end(&mut reader, |entity| match entity {
            Entity::Vertex { x, y, z, w: _w } => {
                positions.push(Vec3::new(x as f32, y as f32, z as f32));
            }
            Entity::Face { vertices } => {
                // NOTE: OBJ Wavefront indices start at 1
                let polygon: SVec<usize> =
                    vertices.iter().map(|v| (v.vertex - 1) as usize).collect();
                polygons.push(polygon);
            }
            _ => {}
        })?;
        halfedge::HalfEdgeMesh::build_from_polygons(&positions, &polygons)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_load_obj() {
        HalfEdgeMesh::from_wavefront_obj("./assets/debug/arrow.obj".into())
            .unwrap()
            .to_wavefront_obj("/tmp/wat.obj".into())
            .unwrap();
    }
}
